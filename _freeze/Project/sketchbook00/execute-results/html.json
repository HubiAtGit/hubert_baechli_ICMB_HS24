{
  "hash": "47381712173a03161af3d6800b4ecfff",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Simple Learningkurve\"\nauthor: \"Hubert Baechli\"\n\nexecute: \n  cache: false\n---\n\n\n\n\n# Simple Learningkurve\n\nFirst and foremost, the disdribution of information and knowledge should have something to do with learning. So I start with an exponential learning curve, which is easy to implement. The basic idea is that when two agents meet, they learn together. Later, this should happen in a network. In the beginning, I will let the agents meet randomly in the population to see if the implementation of joint learning works.\n\n# Definitions\n\nLoading some Packages for easier Data management and Presentation of Results\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n# set.seed(1)\n```\n:::\n\n\n\n\n## Population for testing the Functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnA = 5            # number of Agents\nID = seq_len(nA)  # ID of the Agents\n\nPop <- tibble( ID = ID )\nPop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 1\n     ID\n  <int>\n1     1\n2     2\n3     3\n4     4\n5     5\n```\n\n\n:::\n:::\n\n\n\n\n# Functions\n\n## Knowledge\n\nFunctions to set and update Knowledge\n\n### Set Knowledge \n\n#### Needs\n\n1.  A Population (Pop) with several Agents defined by ID's\n\n2.  A value for the Knowledge (K) between 0 and 1. could be a scalar or e vector with the same length as the Population\n\n3.  optional for future implementations a name (Typ) for the specific Knowledge\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_Knowledge <- function(Pop = Pop,\n                          Typ = FALSE,\n                          K = Knowledge) {\n  Kname <- \"Knowledge\"\n  if (Typ != FALSE) {\n    Kname <- paste(Kname, Typ, sep = \"_\")\n  }\n  if (Kname %in% colnames(Pop)) {\n    Pop <- Pop %>%\n      mutate(!!Kname := K)\n  } else {\n    Pop[[Kname]] <- K\n  }\n  Pop <- Pop %>%\n\n  return(Pop)\n}\n```\n:::\n\n\n\n\n#### Output\n\n1.  Population with the defined Knowledge\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nK <- seq_len(nA)/5\n\nPop <- set_Knowledge( Pop = Pop, K = 0.5 )\nPop <- set_Knowledge( Pop = Pop, Typ = \"A\", K = K )\nPop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n     ID Knowledge Knowledge_A\n  <int>     <dbl>       <dbl>\n1     1       0.5         0.2\n2     2       0.5         0.4\n3     3       0.5         0.6\n4     4       0.5         0.8\n5     5       0.5         1  \n```\n\n\n:::\n:::\n\n\n\n\n### Update Knowledge \n\n#### Needs\n\n1.  A Population (Pop) with several Agents defined by ID's\n\n2.  A value to add to the Knowledge. could be a scalar or e vector with the same length as the Population. if not defined 0 is used to add\n\n3.  A value to multiplie (fac) the Knowledge. could be a scalar or e vector with the same length as the Population. if not defined 1 is used for the multiplikation\n\n4.  optional for future implementations a name (Typ) for the specific Knowledge\n\n#### Hints\n\n-   The add operation is always used first!\n\n-   If the Knowledge is not defined before it will be generated with the start value (add) and the multiplication with the value (fac)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate_Knowledge <- function(Pop = Pop,\n                            Typ = FALSE,\n                            add = 0,\n                            fac = 1) {\n  Kname <- \"Knowledge\"\n  if (Typ != FALSE) {\n    Kname <- paste(Kname, Typ, sep = \"_\")\n  }\n  if (Kname %in% colnames(Pop)) {\n    Pop <- Pop %>%\n      mutate( !!Kname := ( .data[[Kname]] + add ) * fac )\n  } else {\n    Pop <- set_Knowledge(Pop = Pop, K = add, Typ = Typ)\n    Pop <- Pop %>%\n      mutate( !!Kname := .data[[Kname]] * fac )\n  }\n  return(Pop)\n}\n```\n:::\n\n\n\n\n#### Output\n\n1.  Population with the defined Knowledge\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- seq_len(nA)/20\nfac <- seq_len(nA)/10 \n\nPop <- update_Knowledge( Pop = Pop, add = add ) \nPop <- update_Knowledge( Pop = Pop, Typ = \"A\", fac = fac ) \nPop <- update_Knowledge( Pop = Pop, Typ = \"B\", add = add, fac = fac ) \nPop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n     ID Knowledge Knowledge_A Knowledge_B\n  <int>     <dbl>       <dbl>       <dbl>\n1     1      0.55        0.02       0.005\n2     2      0.6         0.08       0.02 \n3     3      0.65        0.18       0.045\n4     4      0.7         0.32       0.08 \n5     5      0.75        0.5        0.125\n```\n\n\n:::\n:::\n\n\n\n\n## LearnRate\n\nFunctions to set and update the learn rate\n\n### Set LearnRate \n\n#### Needs\n\n1.  A Population (Pop) with several Agents defined by ID's\n\n2.  A value for the learn rate (LR) between 0 and 1. could be a scalar or e vector with the same length as the Population\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset_LearnRate <- function(Pop = Pop,\n                          LR = LearnRate) {\n  LRname <- \"LearnRate\"\n  if (LRname %in% colnames(Pop)) {\n    Pop <- Pop %>%\n      mutate(!!LRname := LR)\n  } else {\n    Pop[[LRname]] <- LR\n  }\n  return(Pop)\n}\n```\n:::\n\n\n\n\n#### Output\n\n1.  Population with the defined learn rate\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLR <- seq_len(nA)/5  \nPop <- set_LearnRate( Pop = Pop, LR = LR ) \nPop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n     ID Knowledge Knowledge_A Knowledge_B LearnRate\n  <int>     <dbl>       <dbl>       <dbl>     <dbl>\n1     1      0.55        0.02       0.005       0.2\n2     2      0.6         0.08       0.02        0.4\n3     3      0.65        0.18       0.045       0.6\n4     4      0.7         0.32       0.08        0.8\n5     5      0.75        0.5        0.125       1  \n```\n\n\n:::\n:::\n\n\n\n\n### Update LearnRate by Knowledge\n\n#### Needs\n\n1.  A Population (Pop) with several Agents defined by ID's and Knowledge\n\n2.  optional for future implementations a name (Typ) for the specific Knowledge\n\n#### Hints\n\n-   The learn rate is defined as 50% of the Knowledge for each Agent\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate_LearnRate_Knowledge <- function(Pop = Pop,\n                                       Typ = FALSE) {\n  LR <- \"LearnRate\"\n  Kname <- \"Knowledge\"\n  if (Typ != FALSE) {\n    Kname <- paste(Kname, Typ, sep = \"_\")\n  }\n  if (Kname %in% colnames(Pop)) {\n    Pop <- Pop %>%\n      mutate( !!LR := .data[[Kname]] * 0.5 )\n  }\n  return(Pop)\n}\n```\n:::\n\n\n\n\n#### Output\n\n1.  Population with the defined learn rate\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPop <- update_LearnRate_Knowledge( Pop = Pop )  \nPop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n     ID Knowledge Knowledge_A Knowledge_B LearnRate\n  <int>     <dbl>       <dbl>       <dbl>     <dbl>\n1     1      0.55        0.02       0.005     0.275\n2     2      0.6         0.08       0.02      0.3  \n3     3      0.65        0.18       0.045     0.325\n4     4      0.7         0.32       0.08      0.35 \n5     5      0.75        0.5        0.125     0.375\n```\n\n\n:::\n:::\n\n\n\n\n### \n\n## **Learning Simulation**\n\nFinally, a simulation is created that simulates a certain number of money exchanges.\n\n#### Needs\n\n1.  Number of exchanges\n\n2.  Startdistribition of Money\n\n3.  Steps for the timeline (optional)\n\n#### Output\n\n1.  Summary (Sum) with ID, number of exchanges, Money at beginning and Money at the End\n\n2.  Matrix with Money distribution(Timeline) for given time steps as vectors (if steps \\> 0)\n",
    "supporting": [
      "sketchbook00_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}